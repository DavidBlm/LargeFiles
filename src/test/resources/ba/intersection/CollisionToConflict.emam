package ba.intersection;

component CollisionToConflict{
    ports in B collisionIn,
          in Z indexIn1,
          in Z indexIn2,
          in Q^{2,1} colPosIn,
          in Q^{3,5} trajectoryIn1,
          in Q^{3,5} trajectoryIn2,
          in Q timeCutoff,
          out B conflict;

implementation Math{
    if collisionIn
        //TODO: with norm()?
        Q dx1 = trajectoryIn1(1,indexIn1) - trajectoryIn1(1,indexIn1 + 1);
        Q dy1 = trajectoryIn1(2,indexIn1) - trajectoryIn1(2,indexIn1 + 1);
        Q dist1 = sqrt(dx1*dx1 + dy1*dy1);

        Q dx2 = trajectoryIn2(1,indexIn2) - trajectoryIn2(1,indexIn2 + 1);
        Q dy2 = trajectoryIn2(2,indexIn2) - trajectoryIn2(2,indexIn2 + 1);
        Q dist2 = sqrt(dx2*dx2 + dy2*dy2);

        Q dxp1 = trajectoryIn1(1,indexIn1) - colPosIn(1,1);
        Q dyp1 = trajectoryIn1(2,indexIn1) - colPosIn(2,1);
        Q distp1 = sqrt(dxp1*dxp1 + dyp1*dyp1);

        Q dxp2 = trajectoryIn2(1,indexIn2) - colPosIn(1,1);
        Q dyp2 = trajectoryIn2(2,indexIn2) - colPosIn(2,1);
        Q distp2 = sqrt(dxp2*dxp2 + dyp2*dyp2);

        Q time1 = distp1/dist1 * (trajectoryIn1(3,indexIn1 + 1) - trajectoryIn1(3,indexIn1));
        Q time2 = distp2/dist2 * (trajectoryIn2(3,indexIn2 + 1) - trajectoryIn2(3,indexIn2));

        conflict = abs(time1 - time2) < timeCutoff;
    else
        conflict = False;
    end
}
}